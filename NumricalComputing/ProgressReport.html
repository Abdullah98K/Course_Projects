
DOMAIN DECOMPOSITION AND PARALLEL COMPUTING  for 1D problem 
        

By Abdullah Alkhalifah
Computer Science student
201619160

Introduction

In this project, I would like to demonstrate the volume of time saved and memory usage cut for boundary value problems in the two approaches: Sequintial vs Parallel.
My work will be on my local machine, having 4 cores.
In the end I would like to compare CPU time in both of the approaces for the number of processors used in a run, and the memory allocated for the sequintial approach vs the step size.
My work was split in five mlx files for better modularity.
As we would observe, for huge (most of the times realistic) matrices, parallel computations save huge amount of time.
my whole code will be in the end of the file for your reference

Mathematical Model

￼
where T is the temperature, and x is the displacement on the rod*
assumes a rod of length 32*
with
￼
and a dynamic step size h
α and β which are a domain decomposd boundary values
the boundary condition at x = 0 and x = 32 are obtained from the closed-form solution:
￼

Method

For the parallel approach, after decomposing the domain, find the boundary conditions at the subdomain (using a step size of 1e-1), feed the decomposed domains in the parfor method for various step sizes. My work can be found in Parallel.mlx file. I used bvp4c to solve the BVP sequintally, not intrested in the solution, but mainly in the memory allocated and time. My work is under Sequintial.mlx.
Recording my findings (time and memory usage) in records.mlx file.
In records.mlx, I created five arrays:
* SeqMem: record the memory used in the sequintial code, since the problem is tridiagonal matrix, I skipped complex memory recordings and used the equation:
memory = 4n-1, where n is the dimension of the square matrix.
*  SeqTime, the time taken for every step size when solving using the sequintial approach.
*  SeqTimenp2, the time taken for every step size when solving using the parallel approach with 2 workers.
*  SeqTimenp4, the time taken for every step size when solving using the parallel approach with 4 workers.
Steps, which is an array of step sizes used (h) for both the sequintial and parallel code.
look for the visulaizations below for their relations.
I used BVPsolver.mlx to make my code cleaner and modular, which is just a function for computing the BVPs for domain decomposed problems.
ExactSol.mlx is used to compute the exact solution for the initial and end point of the domain in the heat the equation (x = 0 and x = 32)

Numerical Results
my recordings were put on record.mlx.
step sizes vs. memory usage in the sequintial approach:
h                memory needed
                                                                                                                        1e-1                      1283
                                                                                                                        1e-2                      12803
                                                                                                                        1e-3                      128003
                                                                                                                        1e-4                      1280003
                                                                                                                        1e-5                      12799999
                                                                                                                        1e-6                      128000003

step sizes vs. time needed in the sequintial approach:
h                time (seconds)
                                                                                                                        1e-1                      0.040043
                                                                                                                        1e-2                      0.180039
                                                                                                                        1e-3                      1.462184
                                                                                                                        1e-4                      14.773457
                                                                                                                        1e-5                      1.506344427e+02
                                                                                                                        1e-6                      1.748654457e+03
step sizes vs. time needed in the parallel approach, with workers = 2:
h                    time (seconds)
                                                                                                                        1e-1                      0.043397
                                                                                                                        1e-2                      0.135462
                                                                                                                        1e-3                      0.883868
                                                                                                                        1e-4                      7.837297
                                                                                                                        1e-5                      74.618057
                                                                                                                        1e-6                      9.43587167e+02
step sizes vs. time needed in the parallel approach, with workers = 4:
h                time (seconds)
                                                                                                                        1e-1                      0.037089
                                                                                                                        1e-2                      0.083219
                                                                                                                        1e-3                      0.442316
                                                                                                                        1e-4                      4.058217
                                                                                                                        1e-5                      43.432076
                                                                                                                        1e-6                      6.22005982e+02
Visualizations
because graphs speak louder than text
￼
figure 1: the memory usage (in terms of the non-zero matrix elements) vs the step size.ste

￼
figure 2: the time taken for each of the three approaches

Discussion

In terms of memory allocation, sequential methods tend to explode with the increase of array elements. As can be seen in figure 1, the memory allocated for the method has a somewhat exponitial increase with the decrease of the step size by a factor of 10. This is not fisable in real life engineering problems as most include matrices of very high dimesions.
refering to figure 2, the time needed to solve the problems decreases by a noticeable margin when switching to parallel methods. With parallel methods, the number of workers tend to increase performance and save time, as can be seen when comparing 2 and 4 workers in my code.

Summary
We have seen why when encountering large compuational problems, using parallel computing is very benifical. As they often include huge number of data points. The time saved is can increase our throughput when solving such problems. due to the limitations of my machine (16 GB memory), any step size that is less than 1e-6 will cause the system to crash at the sequintial model, whilst the parallel one works. Memory usage undergoes an exponential behavior with the step size, and this can cause limitations on huge problems.
Both methods got really good accuracy, since the problem is simple and non-oscillating

Code
ExactSol.mlx; for computing the exact solution of the heat equation at a displacement x
%%%ExactSol.mlx%%%
function y = ExactSol(x)
y = 200+20.4671*exp(sqrt(0.05)*x)+79.5329*exp(-1*sqrt(0.05)*x);
end

Sequintial.mlx; for solving the problems in the traditional single processor method
%%%Sequintial.mlx%%%
clear
%function
F = @(x,T) [T(2);-0.05*(200-T(1))];
%boundary condtion for the whole domain
inteval_start = 300;
inteval_end = ExactSol(32);
bcs = @(Ta,Tb) [Ta(1) - inteval_start;Tb(1) - inteval_end];
tic
h = 1e-1;
numpoints = floor((32-0)/h)+1;
n = 4*numpoints-1;
xmesh = linspace(0,32,numpoints);
solinit = bvpinit(xmesh,[1 1]);
sol = bvp4c(F,bcs,solinit);
yvector = sol.y(1,:);
toc
BVPsolver.mlx; a method for calcualting the solution of the BVP given a decomposed domain
%%%BVPsolver.mlx%%%
function sol = BVPsolver(ode,a,b,alpha,beta,h)
numpoints = floor((b-a)/h)+1;
xmesh = linspace(a,b,numpoints);
solinit = bvpinit(xmesh,[1 1]);
bcs = @(Ta,Tb) [Ta(1) - alpha;Tb(1) - beta];
sol = bvp4c(ode,bcs,solinit);
end
Parallel.mlx; for computing the solution in parallel, the code is dynamic and we only need to change np for your desired number of workers
clear; clc
format short
np = 2;
hp = (32-0)/np;
a = 0:hp:32-hp
b = hp:hp:32;
inteval_start = 300;
inteval_end = ExactSol(32);
%function
F = @(x,T) [T(2);-0.05*(200-T(1))];
%boundary condtion for the whole domain
bcs = @(Ta,Tb) [Ta(1) - inteval_start;Tb(1) - inteval_end];


h = 1/np
numpoints = floor((32-0)/h)+1;
xmesh = linspace(0,32,numpoints);
solinit = bvpinit(xmesh,[1 1]);
sol = bvp4c(F,bcs,solinit);
yvector = sol.y(1,:);
%find the coundary conditions (beta and alpha)
alpha = zeros(1,length(a));
beta = zeros(1,length(b));
%get the subdomain boundary condtions
for i=1:length(a)
    index = find(sol.x == a(i));
    alpha(i) = yvector(index);
    index = find(sol.x == b(i));
    beta(i) = yvector(index);
end
tic
h = 1e-6;
parfor i=1:np
    DDsol(i,:) = BVPsolver(F,a(i),b(i),alpha(i),beta(i),h);
end

%get the solution at the integer points in the interval
pointsAr = 0:1:32;
counter = 1;
solutionsAr = zeros(1,33);
for i=1:np
    arr = DDsol(i,:);
    solvector = arr.y(1,:);
    for j=counter:33
        if isempty(find(arr.x == pointsAr(counter)))
            break
        else
            index = find(arr.x == pointsAr(counter));
            solutionsAr(counter) = solvector(index);
            counter = counter + 1;
        end
        
    end
    
end
toc
%final solution
cat(1,pointsAr,solutionsAr)
